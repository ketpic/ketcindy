 /*            MNR solver 

numer(f),denomf(f),frfactor(f)
ratev(eq,rep),frev(eq,rep)
ratevL(eq,repL),frevL(eq,repL)
disc(eq,v),nthfactor(pol,kth)
angtan(m),tanang(t),supA(m),comA(m)
plusA(m1,m2),minusA(m1,m2)
dotProd(v1,v2),normsq(v),crossProd(v1,v2)
eqLine(pa1,pa2),meetLinell(line1,line2)
meetLine(pts1,pts2),
lenSeg2(p1,[p2]),lenSeg(p1,[p2])
vect(A,B),ptDirSeg(A,B,t)
slide(v),rotate(v)
putT(m,n,r)=putTriangle
putTriangle_btm(m,n,btm)
slideT(A,B)=slideTriangle
rotateT(tr,centre)=rotateTriangle
reduceD(pL,z,stp)=reduceDegree
inCircle(p1,p2,p3)
comTan(C1,r1,C2,r2,ch)
comTan1(C1,r1,C2,r2),comTan2(C1,r1,C2,r2)
comTanC(C1,r1,C2,r2,ch)
comTanC1(C1,r1,C2,r2), comTanC2(C1,r1,C2,r2)

////log
251210 comTan, comTanC changed
250424 quaL added
250402 timesA(rp,m), qua[rter](expr,m,M) added
250329 angT ( angT(m,n) changed )
20250321 contCL
20250311 edg2m,m2edg added
20250217 frevL,ratevL dbg
20250212 ratden changed(frfactor, for list)
20250211 commonTan,commonTanR,commonTanC (ev -> subst)
20250208 angT(m,n) added
20250206 ratden added
20250102 edg2m(c,a,b),cos2m,edge added
2024.11.07 frsbsL added
2024.02.09 ratevL,frevL
2024.02.07 comTan1, comTan2, comTanC1, comTanC2
2024.02.03 denomf,Denom,factorfr,frev
2024.01.12 lenSeg
2024.01.06 comtan name
2024.01.05 comtanLR
2024.01.04 comtanLL(RR)
2024.01.01 plusA,minusA
2023.12.31 meetLine
2023.12.30 verT
2023.12.29 reduceD
2023.12.27
2023.12.12
																															 
remvalue(all);
*/

numer(f):=factor(num(ratsimp(f)))$
Numer(f):=numer(f)$
denomf(f):=factor(denom(ratsimp(f)))$
Denom(f):=factor(denom(ratsimp(f)))$
frfactor(f):=numer(f)/denomf(f)$
frfactorL(fL):=block( /*250424*/
 [out,ne,tmpmnrm],
 out:[],
 for ne from 1 thru length(fL) do block(
   tmpmnrm:frfactor(fL[ne]),
   out:endcons(tmpmnrm,out)
 ),
 out
)$
/*factorfr(f):=numer(f)/denomf(f)$*/
ratev(eq,rep):=ratsimp(ev(eq,rep))$
Ratev(eq,rep):=ratev(eq,rep)$
frev(eq,rep):=frfactor(ratev(eq,rep))$
ratevL(eqL,rep):=block( /*250217*/
 [out,ne,tmpmnr],
 out:[],
 for ne from 1 thru length(eqL) do block( /*250424dbg*/
   tmpmnr:ratev(eqL[ne],rep),
   out:endcons(tmpmnr,out)
 ),
 out
)$
/*frevL(eq,repL):=ratevL(eq,repL)$*/
frevL(eqL,rep):=block( /* 250217 */
 [out,ne,tmpmnr],
 out:[],
 for ne from 1 thru length(eqL) do block(
   tmpmnr:frev(eqL[ne],rep),
   out:endcons(tmpmnr,out)
 ),
 out
)$
frsbsL(vL,sol):=block(/*241106*/
  [k,tmpmnr,tmpmnr1,tmpmnr2,out],
  out:[],
  for k from 1 thru length(vL) do block(
    tmpmnr1:frevL(vL[k],sol),
    out:endcons(tmpmnr1,out)
  ),
  return(out)
 )$

disc(eq,v):=block(
 [eqe,v2,v1,v0],
 eqe:expand(eq),
 v2:coeff(eqe,v,2),
 v1:coeff(eqe,v,1),
 v0:coeff(eqe,v,0),
 frfactor(v1^2-4*v2*v0)
)$

nthfactor(pol,kth):=block(
 [tmpmnr,j,out],
 tmpmnr:part(pol,0),
 if tmpmnr="-" then
   tmpmnr:part(pol,1)
 else
   tmpmnr:pol
 ,
 j:length(tmpmnr),
 if kth>j then kth:j,
 part(tmpmnr,kth)
)$


angtan(m):=float(2*atan(m)*180/%pi)$
tanang(t):=float(tan(t/2*%pi/180))$

supA(m):=ratsimp(1/m)$ /*hokaku*/
comA(m):=ratsimp((1-m)/(m+1))$ /*yokaku*/
Hokaku(m):=ratsimp(1/m)$
Yokaku(m):=ratsimp((1-m)/(m+1))$
plusA(m1,m2):=ratsimp((m1+m2)/(1-m2*m1))$
minusA(m1,m2):=ratsimp((m1-m2)/(1+m2*m1))$
timesA(nn,m):=block([k,mm],
  mm:m,
  for k from 2 thru nn do mm:plusA(mm,m),
  return(mm)
)$
edge(A,B):=block(
  [out],
  out:frfactor(lenSeg2(A,B)),
  out:frfactor(sqrt(out))
)$
edg2m(c,a,b):=block(
  [cs,out],
  cs:(a^2+b^2-c^2)/(2*a*b),
  out:sqrt(frfactor((1-cs)/(1+cs))),
  out:frfactor(out)
)$
m2edg(m,a,b):=block(/*250311*/
  [cs,out],
  cs:(1-m^2)/(1+m^2),
  out:sqrt(frfactor(a^2+b^2-2*a*b*cs)),
  out:frfactor(out)
)$

cos2m(c):=block(
  [out],
  out:sqrt(frfactor((1-c)/(1+c))),
  out:frfactor(out)
)$

dotProd(v1,v2):=
  ratsimp(v1[1]*v2[1]+v1[2]*v2[2])$
normsq(v):=
  ratsimp(v[1]^2+v[2]^2)$
crossProd(v1,v2):=
  ratsimp(v1[1]*v2[2]-v1[2]*v2[1])$ 

eqLine(pa1,pa2):=block(
  [tmpmnr,tmpmnr1,tmpmnr2,out],
  if pa1[1]=pa2[1] then
    tmpmnr:_X-pa1[1]
  else block(
    tmpmnr1:pa2[1]-pa1[1],
	tmpmnr2:pa2[2]-pa1[2],
    tmpmnr:_Y-(pa1[2]+tmpmnr2/tmpmnr1*(_X-pa1[1]))
  ),
  out:numer(tmpmnr)
)$

meetLinell(line1,line2):=block(
  [out],
  out:solve([line1,line2],[_X,_Y]),
  if length(out)>0 then block( /*250422from*/
    out:ratev([_X,_Y],out),
    out:frfactor(out)
  ) /*250422to*/
)$

meetLine(pts1,pts2):=block(
  [tmpmnr1,tmpmnr2,out],
  tmpmnr1:eqLine(pts1[1],pts1[2]),
  tmpmnr2:eqLine(pts2[1],pts2[2]),
  out:meetLinell(tmpmnr1,tmpmnr2),
  out
)$

/*
line1:eqLine([2,1],[4,3]);
line2:eqLine([a,b],[c,d]);
intsectLine(line1,line2);
*/

lenSeg2(p1,[p2]):=block(
 [tmpmnr],
 if length(p2)>0 then
   tmpmnr:(p2[1][1]-p1[1])^2+(p2[1][2]-p1[2])^2
 else
   tmpmnr:(p1[1])^2+(p1[2])^2,
 ratsimp(tmpmnr)
)$
lenSeg(p1,[p2]):=block(
 [tmpmnr],
 if length(p2)>0 then
   tmpmnr:(p2[1][1]-p1[1])^2+(p2[1][2]-p1[2])^2
 else
   tmpmnr:(p1[1])^2+(p1[2])^2,
 ratsimp(sqrt(tmpmnr))
)$
vect(A,B):=ratsimp(B-A)$
ptDirSeg(A,B,t):=ratsimp([A[1]+t*(B[1]-A[1]),A[2]+t*(B[2]-A[2])])$

/*---------------------*/

/*
assume(m>0,n>0,r>0,m^2+1>0,n^2+1>0,m*n-1<0)$
forget(...) 
*/

slide(v):=ratsimp(v+sliderVector)$
rotate(v):=block(
  [x,y,c,s,u],
  x:v[1]-rotCenter[1],
  y:v[2]-rotCenter[2],
  c:rotCS[1],
  s:rotCS[2],
  u:[c*x-s*y,s*x+c*y],
  ratsimp(u+rotCenter)
)$

putTriangle(m,n,r) := block(
  mAng:m,
  nAng:n,
  inR:r,
  assume(mAng>0,nAng>0,inR>0,mAng*nAng-1<0),
  edgeLeft:r*(1 + m^2)/(m*(1 - n*m)),
  edgL:edgeLeft,
  edgeRight:r*(1 + n^2)/(n*(1 - n*m)),
  edgR:edgeRight,
  edgeBottom:r*(m + n)/(n*m),
  edgB:edgeBottom,
  cirR:r*(m^2+1)*(n^2+1)/(4*m*n*(1-m*n)),
  angT:supA(plusA(m,n)),
  exRa:r/(m*n),
  exRb:r*(m+n)/(m*(1-m*n)),
  exRc:r*(m+n)/(n*(1-m*n)),
  area:r^2*(m+n)/(m*n*(1-m*n)),
  halfPer:r*(m+n)/(m*n*(1-m*n)),
  half:halfPer,
  inCenter:[0,0],
  inC:inCenter,
  vertexLeft:[-r/m,-r],
  verL:vertexLeft, vtxL:verL,
  vertexRight:[r/n,-r],
  verR:vertexRight, vtxR:verR,
  vertexTop:[r*(n-m)/(1-m*n),r*(1+m*n)/(1-m*n)],
  verT:vertexTop, vtxT:verT,
  cirCenter:[r*(m-n)/(2*m*n),
             r*(m^2+3*m^2*n^2+n^2-1)/(4*m*n*(1-m*n))],
  cirC:cirCenter,
  barCenter:[r*(2*m*n-1)*(n-m)/(3*m*n*(1-m*n)),
              r*(3*m*n-1)/(3*(1-m*n))],
  barC:barCenter,
  ortCenter:[r*(n-m)/(1-m*n),
             r*(3*m^2*n^2-m^2-2*m*n-n^2+1)/(2*m*n*(1-m*n))],
  ortC:ortCenter,
  exCentera:[r*(m-n)/(m*n),-r*(m*n+1)/(m*n)],
  exCa:exCentera,
  exCenterb:[-r*(1+m^2)/(m*(1-m*n)),r*n*(1+m^2)/(m*(1-m*n))],
  exCb:exCenterb,
  exCenterc:[r*(1+n^2)/(n*(1-m*n)),r*m*(1+n^2)/(n*(1-m*n))], 
  exCc:exCenterc,  
  sliderVector:[0,0],
  rotCenter:[0,0],
  rotCsSn:[1,0],
  [vertexTop,vertexLeft,vertexRight,inCenter]
)$
putT(m,n,r):=putTriangle(m,n,r)$

putTriangle_btm(m,n,btm):=block(
  [r,ans],
  putTriangle(m,n,r),
  ans:ratsimp(solve(edgeBottom=btm,r)),
  putTriangle(m,n,ans),
  [vertexTop,vertexLeft,vertexRight,inCenter]
)$

slideTriangle(A,B):=block(
  sliderVector:[B[1]-A[1],B[2]-A[2]],
  inCenter:slide(inCenter),
  inC:inCenter,
  vertexLeft:slide(vertexLeft),
  verL:vertexLeft, vtxL:verL,
  vertexRight:slide(vertexRight),
  verR:vertexRight, vtxR:verR,
  vertexTop:slide(vertexTop), 
  verT:vertexTop, vtxT:verT,
  cirCenter:slide(cirCenter),
  cirC:cirCenter,
  barCenter:slide(barCenter),
  barC:barCenter,
  ortCenter:slide(ortCenter),
  ortC:ortCenter,
  exCentera:slide(exCentera),
  exCa:exCentera,
  exCenterb:slide(exCenterb),
  exCb:exCenterb,
  exCenterc:slide(exCenterc),
  exCc:exCenterc,
  [vertexTop,vertexLeft,vertexRight,inCenter]
)$
slideT(A,B):=slideTriangle(A,B)$

rotateTriangle(tr,centre):=block(
  rotCenter:centre,
  rotCS:[(1-tr^2)/(1+tr^2),2*tr/(1 + tr^2)],
  inCenter:rotate(inCenter), inC:inCenter,
  vertexLeft:rotate(vertexLeft),
  verL:vertexLeft, vtxL:verL,
  vertexRight:rotate(vertexRight),
  verR:vertexRight, vtxR:verR,
  vertexTop:rotate(vertexTop),
  verT:vertexTop, vtxT:verT,
  cirCenter:rotate(barCenter),
  cirC:cirCenter,
  ortCenter:rotate(ortCenter),
  ortC:ortCenter,
  barCenter:rotate(barCenter),
  barC:barCenter,
  exCentera:rotate(exCentera),
  exCa:exCentera,
  exCenterb:rotate(exCenterb),
  exCb:exCenterb,
  exCenterc:rotate(exCenterc),
  exCc:exCenterc,
  [vertexTop,vertexLeft,vertexRight,inCenter]
)$
rotateT(tr,centre):=rotateTriangle(tr,centre)$

/*angT(m,n):=supA(plusA(m,n));*/

reduceDegree(pL,z,stp):=block(
  [stpL,dg1,dg2,co1,co2,tmpmnr,tmpmnr1,tmpmnr2,ctr,out], 
  tmpmnr1:expand(pL[1]), 
  tmpmnr2:expand(pL[2]), 
  dg1:hipow(tmpmnr1,z),
  dg2:hipow(tmpmnr2,z), 
  ctr:1,
  stpL:[],
  while ((not dg2=0) and (not dg1=0)) and (ctr<=stp) do block(
	co1:diff(tmpmnr1,z,dg1)/factorial(dg1),
	co2:diff(tmpmnr2,z,dg2)/factorial(dg2),
	tmpmnr:gcd(co1,co2),
	co1:ratsimp(co1/tmpmnr),
	co2:ratsimp(co2/tmpmnr),
	if dg2<dg1 then block(
      tmpmnr1:expand(co2*tmpmnr1-co1*tmpmnr2*z^(dg1-dg2)),
   	  dg1:hipow(tmpmnr1,z)
    )else block(
	  tmpmnr2:expand(co2*tmpmnr1*z^(dg2-dg1)-co1*tmpmnr2),
	  dg2:hipow(tmpmnr2,z)
    ), 
	stpL:append(stpL,[tmpmnr1,tmpmnr2]),
	ctr:ctr + 1
  ),
  tmpmnr1:factor(tmpmnr1),
  tmpmnr2:factor(tmpmnr2),
  [tmpmnr1,tmpmnr2,ctr,dg1,dg2,stpL]
)$
reduceD(pL,z,stp):=reduceDegree(pL,z,stp)$

/* inner cirle  
inCircle(p1,p2,p3):=block(
  [a,b,c,S,s,tmpmnr,out],
  a:normsq(p2-p3),
  b:normsq(p3-p1),
  c:normsq(p1-p2),
  a:ratsimp(sqrt(a)),
  b:ratsimp(sqrt(b)),
  c:ratsimp(sqrt(c)),
  s:(a+b+c)/2,
  S:sqrt(s*(s-a)*(s-b)*(s-c)),
  tmpmnr:(a*p1+b*p2+c*p3)/(2*s),
  out:ratsimp([S/s,tmpmnr]),
  out
)$
*/

/*
commonTan(C1,r1,C2,r2,ch):=block(
  [mL,x1,y1,x2,y2,pA1,pB1,pC1,pA2,pB2,pC2,v1,v2,
   eq,sol,sol1,sol2,tmpmnr,tmpmnr1,out],
  x1:C1[1], y1:C1[2],
  x2:C2[1], y2:C2[2],
  putTriangle(mL,1,r1),
  slideTriangle([0,0],C1),
  pA1:vertexTop,
  pB1:vertexLeft,
  pC1:vertexRight,
  putTriangle(mL,1,r2), 
  slideTriangle([0,0],C2),
  pA2:vertexTop,
  pB2:vertexLeft,
  pC2:vertexRight,
  v1:ratsimp(pA1-pB1),
  v2:ratsimp(pA2-pB1),
  tmpmnr:crossProd(v1,v2),
  eq:numer(tmpmnr),
  sol:solve(eq,mL),
  tmpmnr:sol[ch],
  pA1:ratev(pA1,tmpmnr),
  pB1:ratev(pB1,tmpmnr),
  pA1:frfactor(subst(tmpmnr,pA1)),
  pB1:frfactor(subst(tmpmnr,pB1)),
  out:[pA1,pB1],
  out
)$
?
*/

/* 251122,251209 */
commonTan(C1,r1,C2,r2,ch):=block(
  [mL,x1,y1,x2,y2,pA1,pB1,pC1,pA2,pB2,pC2,v1,v2,
   eq,c2,c1,c0,Dis,sol,tempmnr,tempmnr1,out],
  x1:C1[1], y1:C1[2],
  x2:C2[1], y2:C2[2],
  putTriangle(mL,1,r1),
  slideTriangle([0,0],C1),
  pA1:vertexTop,
  pB1:vertexLeft,
  pC1:vertexRight,
  putTriangle(mL,1,r2), 
  slideTriangle([0,0],C2),
  pA2:vertexTop,
  pB2:vertexLeft,
  pC2:vertexRight,
  v1:frfactor(pA1-pB1),
  v2:frfactor(pA2-pB1),
  tempmnr:crossProd(v1,v2),
  eq:expand(numer(tempmnr)),
  sol:solve(eq,mL),
  Dis:0,
/*  dis:0, */
  if length(sol)=2 then block(
    c2:coeff(eq,mL,2),
    c1:coeff(eq,mL,1),
    c0:coeff(eq,mL,0),
    Dis:frfactor(c1^2-4*c2*c0),
/*    dis:radcan(sqrt(Dis)), */
    sol:[mL=(-c1+dis)/(2*c2),mL=(-c1-dis)/(2*c2)],
    sol:sol[ch]
  ),
  pA1:frfactor(subst(sol,pA1)),
  pB1:frfactor(subst(sol,pB1)),
  out:[pA1,pB1,Dis],
  out
)$
comTan(C1,r1,C2,r2,ch):=commonTan(C1,r1,C2,r2,ch)$/*251210*/
comTan1(C1,r1,C2,r2):=commonTan(C1,r1,C2,r2,1)$
comTan2(C1,r1,C2,r2):=commonTan(C1,r1,C2,r2,2)$

commonTanC(C1,r1,C2,r2,ch):=block(
   [x1,y1,x2,y2,pA1,pB1,pA2,pC2,v1,v2,Dis,dis,
    eq1,eq2,sol,sol1,sol2,tempmnr,tempmnr1,out],
  x1:C1[1], y1:C1[2],
  x2:C2[1], y2:C2[2],
  putTriangle(mL,1,r1),
  slideTriangle([0, 0],C1),
  pA1:vertexTop,
  pB1:vertexLeft,
  putTriangle(1,1/mL,r2),
  slideTriangle([0,0],C2),
  pA2:vertexTop,
  pC2:vertexRight,
  v1:ratsimp(pA1-pB1),
  v2:ratsimp(pA2-pB1),
  tempmnr:crossProd(v1,v2),
  eq:expand(numer(tempmnr)),
  sol:solve(eq,mL),
  Dis:0,
  if length(sol)=2 then block(
    c2:coeff(eq,mL,2),
    c1:coeff(eq,mL,1),
    c0:coeff(eq,mL,0),
    Dis:frfactor(c1^2-4*c2*c0),
    sol:[mL=(-c1+dis)/(2*c2),mL=(-c1-dis)/(2*c2)],
    sol:sol[ch]
  ),
  pA1:frfactor(subst(tempmnr,pA1)),
  pB1:frfactor(subst(tempmnr,pB1)),
  out:[pA1,pB1,Dis,sqrt(Dis)],
  out
)$
comTanC(C1,r1,C2,r2,ch):=commonTanC(C1,r1,C2,r2,ch)$
comTanC1(C1,r1,C2,r2):=commonTanC(C1,r1,C2,r2,1)$
comTanC2(C1,r1,C2,r2):=commonTanC(C1,r1,C2,r2,2)$

ratden(s,x,a):=block( /*Rationalize denom 250206*/
  [sL,lflg,len,j,tmpmnrn,tmpmnrd,tmpmnrr,ns,ds,mul,out],
  if not listp(s) then block(
    ns:num(s), ds:denom(s),
    ns:remainder(ns,x^2-a),
    ds:remainder(ds,x^2-a),
    ds:expand(ds),
    c1:coeff(ds,x,1),
    c0:coeff(ds,x,0),
    mul:c1*x-c0,
    tmpmnrn:remainder(ns*mul,x^2-a),
    tmpmnrd:remainder(ds*mul,x^2-a),
    out:frfactor(tmpmnrn/tmpmnrd)
  ),
  if listp(s) then block(
    len:length(s),
    out:[],
    for j from 1 thru len do block(
      tmpmnrr:ratden(s[j],x,a),
      out:endcons(tmpmnrr,out)
    )
  ),
  return(out)
)$

contCL(C,r,P1,P2):=block(
   [eq],
  eq:crossProd(P2-P1,C-P1)^2/lenSeg2(P2-P1)-r^2,
  eq:numer(eq),
  return(eq)
)$

quarter(expr,m,M):=block(
  [out],
  out:frev(expr,sqrt(m^2+1)=(1+M^2)/(1-M^2)),
  out:frev(out,m=2*M/(1-M^2)),
  return(out)
)$
qua(expr,m,M):=quarter(expr,m,M)$
quaL(exL,m,M):=block(
  [k,tmpmnrm,out],
  out:[],
  for k from 1 thru length(exL) do block(
    tmpmnrm:qua(exL[k],m,M),
    out:endcons(tmpmnrm,out)
  ),
  return(out)
)$

quasubs(p,m,M):=
  frev(p,[sqrt(m^2+1)=(1+M^2)/(1-M^2),m=2*M/(1-M^2)])$

